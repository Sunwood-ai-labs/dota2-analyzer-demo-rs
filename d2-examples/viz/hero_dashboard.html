<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dota 2 Hero Dashboard</title>
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 120 120'%3E%3Crect width='120' height='120' rx='24' fill='%23222'/%3E%3Ctext x='60' y='78' text-anchor='middle' font-size='72' fill='white' font-family='Arial'%3ED%3C/text%3E%3C/svg%3E">
  <style>
    :root {
      color-scheme: dark;
      --bg: #101418;
      --surface: #161c22;
      --surface-alt: #1d242d;
      --border: rgba(255,255,255,0.08);
      --accent-radiant: #1f77b4;
      --accent-dire: #d62728;
      --accent-neutral: #7f7f7f;
      --text: #edf1f5;
      --text-dim: #92a0b0;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 24px;
      font-family: "Segoe UI", "Noto Sans JP", system-ui, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }
    h1 {
      font-size: 1.8rem;
      letter-spacing: 0.02em;
      margin: 0 0 16px;
      display: flex;
      align-items: center;
      gap: 12px;
    }
    h2 {
      font-size: 1.2rem;
      margin: 0 0 12px;
      color: var(--text);
    }
    .layout {
      display: grid;
      gap: 18px;
    }
    .card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 12px 32px rgba(0,0,0,0.2);
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: center;
      font-size: 0.95rem;
    }
    label {
      display: flex;
      flex-direction: column;
      font-size: 0.82rem;
      color: var(--text-dim);
      gap: 6px;
    }
    .file-picker {
      display: inline-flex;
      align-items: center;
      gap: 10px;
    }
    .file-picker input[type="file"] {
      position: absolute;
      width: 0.1px;
      height: 0.1px;
      opacity: 0;
      overflow: hidden;
      z-index: -1;
    }
    .file-picker label {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 14px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.08);
      background: linear-gradient(135deg, rgba(130, 219, 255, 0.15), rgba(76, 201, 240, 0.05));
      font-weight: 600;
      color: #d7f3ff;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease;
    }
    .file-picker label:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(76, 201, 240, 0.25);
    }
    .file-picker label span {
      font-size: 0.75rem;
      color: var(--text-dim);
      font-weight: 400;
    }
    input[type="range"],
    input[type="range"],
    select {
      background: var(--surface-alt);
      border: 1px solid var(--border);
      color: var(--text);
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 0.95rem;
    }
    input[type="range"] {
      width: 240px;
      padding: 0;
      height: 4px;
      accent-color: #4cc9f0;
    }
    .summary-grid {
      display: grid;
      gap: 12px;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    }
    .summary-card {
      background: var(--surface-alt);
      border-radius: 10px;
      padding: 14px;
      border: 1px solid var(--border);
      display: grid;
      gap: 6px;
    }
    .summary-label {
      font-size: 0.8rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      color: var(--text-dim);
    }
    .summary-value {
      font-size: 1.4rem;
      font-weight: 700;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.9rem;
    }
    thead {
      background: rgba(255,255,255,0.04);
    }
    th, td {
      padding: 10px 12px;
      text-align: left;
      border-bottom: 1px solid var(--border);
    }
    tr:last-child td {
      border-bottom: none;
    }
    tbody tr:hover {
      background: rgba(255,255,255,0.04);
    }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 8px;
      font-size: 0.78rem;
      font-weight: 600;
      text-transform: uppercase;
    }
    .tag-radiant { background: rgba(31, 119, 180, 0.15); color: #81c9ff; }
    .tag-dire { background: rgba(214, 39, 40, 0.15); color: #ff9aa4; }
    .tag-neutral { background: rgba(127, 127, 127, 0.15); color: #d3d3d3; }
    #charts {
      display: grid;
      gap: 16px;
      grid-template-columns: repeat(auto-fit, minmax(320px, 1fr));
    }
    .chart-card {
      min-height: 360px;
    }
    #mapPane {
      min-height: 420px;
    }
    .meta {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      font-size: 0.85rem;
      color: var(--text-dim);
    }
    .hidden {
      display: none !important;
    }
    a {
      color: #82dbff;
    }
    @media (max-width: 600px) {
      body { padding: 16px; }
      .controls { flex-direction: column; align-items: stretch; }
      input[type="range"] { width: 100%; }
    }
  </style>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
</head>
<body>
  <h1>🛠️ Dota 2 Hero Dashboard</h1>
  <div class="layout">
    <section class="card controls">
      <div class="file-picker">
        <input id="fileInput" type="file" accept=".csv" />
        <label for="fileInput">
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.6" stroke-linecap="round" stroke-linejoin="round">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="17 8 12 3 7 8"/>
            <line x1="12" y1="3" x2="12" y2="15"/>
          </svg>
          CSVをアップロード
          <span>手元のCSVで差し替える</span>
        </label>
      </div>
      <label>
        Tick
        <input id="tickSlider" type="range" min="0" max="0" value="0" disabled />
      </label>
      <div>
        <div id="tickLabel" style="font-weight:600;">Tick —</div>
        <div class="meta" id="metaInfo">読み込み待ち...</div>
      </div>
    </section>

    <section class="card">
      <h2>チームサマリー</h2>
      <div class="summary-grid" id="summaryCards">
        <div class="summary-card">データが未読み込みです</div>
      </div>
    </section>

    <section class="card">
      <h2>ヒーロー一覧（最新Tick順）</h2>
      <div style="overflow:auto;">
        <table id="heroTable">
          <thead>
            <tr>
              <th>ヒーロー</th>
              <th>チーム</th>
              <th>Lv</th>
              <th>Net Worth</th>
              <th>Gold (Rel/Unrel)</th>
              <th>GPM</th>
              <th>XPM</th>
              <th>XP</th>
              <th>HP</th>
              <th>Mana</th>
            </tr>
          </thead>
          <tbody>
            <tr><td colspan="10">データが未読み込みです</td></tr>
          </tbody>
        </table>
      </div>
    </section>

    <section id="charts">
      <div class="card chart-card">
        <h2>Net Worth 推移</h2>
        <div id="netWorthChart" style="width:100%;height:320px;"></div>
      </div>
      <div class="card chart-card">
        <h2>Total XP 推移</h2>
        <div id="xpChart" style="width:100%;height:320px;"></div>
      </div>
    </section>

    <section class="card" id="mapPane">
      <h2>位置ヒートマップ</h2>
      <div id="mapChart" style="width:100%;height:360px;"></div>
    </section>
  </div>

  <script>
    const TEAM_INFO = {
      2: { name: 'Radiant', color: '#1f77b4', tag: 'tag-radiant' },
      3: { name: 'Dire', color: '#d62728', tag: 'tag-dire' },
      default: { name: 'Neutral', color: '#7f7f7f', tag: 'tag-neutral' },
    };

    const numberFmt = new Intl.NumberFormat('ja-JP');
    const floatFmt = new Intl.NumberFormat('ja-JP', { maximumFractionDigits: 1, minimumFractionDigits: 1 });

    const state = {
      rows: [],
      ticks: [],
      tickTimes: new Map(),
      rowsByTick: new Map(),
      heroes: new Map(),
      axis: { x: [-2000, 2000], y: [-2000, 2000] },
    };

    const fileInput = document.getElementById('fileInput');
    const tickSlider = document.getElementById('tickSlider');
    const tickLabel = document.getElementById('tickLabel');
    const metaInfo = document.getElementById('metaInfo');
    const summaryCards = document.getElementById('summaryCards');
    const heroTableBody = document.querySelector('#heroTable tbody');

    fileInput.addEventListener('change', async (event) => {
      const file = event.target.files?.[0];
      if (!file) return;

      metaInfo.textContent = 'CSV解析中...';
      try {
        const rows = await parseCsv(file);
        await renderRows(rows, file.name);
      } catch (err) {
        console.error(err);
        metaInfo.textContent = '解析に失敗しました。CSVの形式を確認してください。';
      }
    });

    tickSlider.addEventListener('input', (event) => {
      const idx = Number(event.target.value);
      updateMap(idx);
    });

    function parseCsv(file) {
      return new Promise((resolve, reject) => {
        Papa.parse(file, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          complete: (res) => resolve(res.data.filter(r => Number.isFinite(r.tick))),
          error: reject,
        });
      });
    }

    async function renderRows(rows, label = 'dataset') {
      if (!rows || !rows.length) {
        metaInfo.textContent = 'CSVに有効なデータがありません';
        return;
      }
      hydrateState(rows);
      buildSummary();
      buildTable();
      buildCharts();
      initSlider();
      if (state.ticks.length) {
        updateMap(state.ticks.length - 1);
      }
      metaInfo.textContent = `${label} | ticks=${state.ticks.length} | heroes=${state.heroes.size}`;
    }

    function parseCsvText(text) {
      return new Promise((resolve, reject) => {
        Papa.parse(text, {
          header: true,
          dynamicTyping: true,
          skipEmptyLines: true,
          complete: (res) => resolve(res.data.filter(r => Number.isFinite(r.tick))),
          error: reject,
        });
      });
    }

    function hydrateState(rawRows) {
      state.rows = rawRows
        .map(row => ({
          ...row,
          tick: Number(row.tick),
          entity_index: Number(row.entity_index),
          team: Number(row.team),
          player_id: Number(row.player_id),
          level: Number(row.level),
          current_xp: Number(row.current_xp),
          total_xp: Number(row.total_xp),
          reliable_gold: Number(row.reliable_gold),
          unreliable_gold: Number(row.unreliable_gold),
          total_gold: Number(row.total_gold),
          net_worth: Number(row.net_worth),
          gpm: Number(row.gpm),
          xpm: Number(row.xpm),
          health: Number(row.health),
          max_health: Number(row.max_health),
          mana: Number(row.mana),
          max_mana: Number(row.max_mana),
          x: Number(row.x),
          y: Number(row.y),
          z: Number(row.z),
          time_s: Number(row.time_s),
        }))
        .sort((a, b) => a.tick - b.tick || a.entity_index - b.entity_index);

      state.ticks = Array.from(new Set(state.rows.map(r => r.tick))).sort((a, b) => a - b);
      state.tickTimes.clear();
      state.rowsByTick = new Map();
      for (const row of state.rows) {
        if (!state.tickTimes.has(row.tick)) {
          state.tickTimes.set(row.tick, row.time_s ?? row.tick / 30);
        }
        if (!state.rowsByTick.has(row.tick)) {
          state.rowsByTick.set(row.tick, []);
        }
        state.rowsByTick.get(row.tick).push(row);
      }

      state.axis = computeAxis(state.rows);
      state.heroes = buildHeroes(state.rows);
    }

    function computeAxis(rows) {
      const xs = rows.map(r => r.x).filter(Number.isFinite);
      const ys = rows.map(r => r.y).filter(Number.isFinite);
      if (!xs.length || !ys.length) {
        return { x: [-2000, 2000], y: [-2000, 2000] };
      }
      const pad = 200;
      const xmin = xs.reduce((acc, v) => (v < acc ? v : acc), xs[0]) - pad;
      const xmax = xs.reduce((acc, v) => (v > acc ? v : acc), xs[0]) + pad;
      const ymin = ys.reduce((acc, v) => (v < acc ? v : acc), ys[0]) - pad;
      const ymax = ys.reduce((acc, v) => (v > acc ? v : acc), ys[0]) + pad;
      return { x: [xmin, xmax], y: [ymin, ymax] };
    }

    function buildHeroes(rows) {
      const heroes = new Map();
      for (const row of rows) {
        const key = `${row.player_id}_${row.entity_index}`;
        if (!heroes.has(key)) {
          const label = chooseLabel(row);
          heroes.set(key, {
            key,
            team: row.team,
            data: [],
            label,
          });
        }
        const hero = heroes.get(key);
        if (row.player_name && row.player_name.trim()) {
          hero.label = row.player_name.trim();
        }
        hero.data.push(row);
      }
      heroes.forEach(hero => {
        hero.data.sort((a, b) => a.tick - b.tick);
        hero.latest = hero.data[hero.data.length - 1];
      });
      return heroes;
    }

    function chooseLabel(row) {
      if (row.player_name && row.player_name.trim()) return row.player_name.trim();
      if (row.class && row.class.trim()) return `${row.class} (#${row.entity_index})`;
      return `Entity ${row.entity_index}`;
    }

    function buildSummary() {
      const radiant = { net: 0, heroes: 0 };
      const dire = { net: 0, heroes: 0 };
      state.heroes.forEach(hero => {
        const latest = hero.latest;
        const worth = latest && latest.net_worth >= 0 ? latest.net_worth : 0;
        if (hero.team === 2) {
          radiant.net += worth;
          radiant.heroes += 1;
        } else if (hero.team === 3) {
          dire.net += worth;
          dire.heroes += 1;
        }
      });
      const delta = radiant.net - dire.net;

      summaryCards.innerHTML = '';
      summaryCards.appendChild(buildSummaryCard('Radiant Net Worth', radiant.net, TEAM_INFO[2].color, `${radiant.heroes} heroes`));
      summaryCards.appendChild(buildSummaryCard('Dire Net Worth', dire.net, TEAM_INFO[3].color, `${dire.heroes} heroes`));
      summaryCards.appendChild(buildSummaryCard('Net Worth Δ (Rad - Dire)', delta, delta >= 0 ? '#55efc4' : '#ff7675'));
    }

    function buildSummaryCard(title, value, color, footnote = '') {
      const card = document.createElement('div');
      card.className = 'summary-card';
      const label = document.createElement('div');
      label.className = 'summary-label';
      label.textContent = title;
      const content = document.createElement('div');
      content.className = 'summary-value';
      content.style.color = color;
      content.textContent = numberFmt.format(Math.round(value));
      card.append(label, content);
      if (footnote) {
        const note = document.createElement('div');
        note.style.fontSize = '0.75rem';
        note.style.color = 'var(--text-dim)';
        note.textContent = footnote;
        card.appendChild(note);
      }
      return card;
    }

    function buildTable() {
      const heroes = Array.from(state.heroes.values()).sort((a, b) => {
        const worthA = a.latest?.net_worth ?? -1;
        const worthB = b.latest?.net_worth ?? -1;
        return worthB - worthA;
      });

      heroTableBody.innerHTML = '';
      heroes.forEach(hero => {
        const latest = hero.latest;
        const tr = document.createElement('tr');
        const teamInfo = TEAM_INFO[hero.team] ?? TEAM_INFO.default;
        tr.innerHTML = `
          <td>${latest?.player_name || hero.label}</td>
          <td><span class="tag ${teamInfo.tag}">${teamInfo.name}</span></td>
          <td>${displayInt(latest?.level)}</td>
          <td>${displayGold(latest?.net_worth)}</td>
          <td>${displayGold(latest?.reliable_gold)}/${displayGold(latest?.unreliable_gold)}</td>
          <td>${displayRate(latest?.gpm)}</td>
          <td>${displayRate(latest?.xpm)}</td>
          <td>${displayInt(latest?.total_xp)}</td>
          <td>${displayHp(latest?.health, latest?.max_health)}</td>
          <td>${displayMana(latest?.mana, latest?.max_mana)}</td>
        `;
        heroTableBody.appendChild(tr);
      });
    }

    function buildCharts() {
      const netWorthTraces = [];
      const xpTraces = [];
      state.heroes.forEach(hero => {
        const teamInfo = TEAM_INFO[hero.team] ?? TEAM_INFO.default;
        const xs = hero.data.map(d => d.tick);
        const worth = hero.data.map(d => sanitizeValue(d.net_worth));
        const xp = hero.data.map(d => sanitizeValue(d.total_xp));

        netWorthTraces.push({
          x: xs,
          y: worth,
          mode: 'lines',
          name: hero.label,
          line: { width: 2, color: teamInfo.color },
          hovertemplate: `${hero.label}<br>Tick %{x}<br>Net Worth %{y:,}<extra></extra>`,
        });
        xpTraces.push({
          x: xs,
          y: xp,
          mode: 'lines',
          name: hero.label,
          line: { width: 2, dash: hero.team === 2 ? 'solid' : 'dot', color: teamInfo.color },
          hovertemplate: `${hero.label}<br>Tick %{x}<br>Total XP %{y:,}<extra></extra>`,
        });
      });

      Plotly.react('netWorthChart', netWorthTraces, {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        legend: { orientation: 'h', x: 0, y: 1.15 },
        xaxis: { title: 'Tick' },
        yaxis: { title: 'Net Worth', rangemode: 'tozero' },
        margin: { l: 60, r: 20, t: 40, b: 40 },
      }, { responsive: true, displaylogo: false });

      Plotly.react('xpChart', xpTraces, {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        legend: { orientation: 'h', x: 0, y: 1.15 },
        xaxis: { title: 'Tick' },
        yaxis: { title: 'Total XP', rangemode: 'tozero' },
        margin: { l: 60, r: 20, t: 40, b: 40 },
      }, { responsive: true, displaylogo: false });
    }

    function initSlider() {
      if (!state.ticks.length) {
        tickSlider.disabled = true;
        tickSlider.value = 0;
        tickLabel.textContent = 'Tick —';
        return;
      }
      tickSlider.disabled = false;
      tickSlider.min = 0;
      tickSlider.max = state.ticks.length - 1;
      tickSlider.value = state.ticks.length - 1;
      updateTickLabel(state.ticks.length - 1);
    }

    function updateMap(tickIndex) {
      const tick = state.ticks[tickIndex];
      updateTickLabel(tickIndex);
      const rows = state.rowsByTick.get(tick) ?? [];

      const groups = {
        2: { x: [], y: [], text: [] },
        3: { x: [], y: [], text: [] },
        other: { x: [], y: [], text: [] },
      };

      rows.forEach(row => {
        const label = `${row.player_name || chooseLabel(row)} (Lv ${displayInt(row.level)})`;
        const text = `${label}<br>Net Worth: ${displayGold(row.net_worth)}<br>XP: ${displayInt(row.total_xp)}`;
        const entry = row.team === 2 ? groups[2] : row.team === 3 ? groups[3] : groups.other;
        entry.x.push(row.x);
        entry.y.push(row.y);
        entry.text.push(text);
      });

      const traces = [
        {
          name: 'Radiant',
          x: groups[2].x,
          y: groups[2].y,
          mode: 'markers',
          type: 'scattergl',
          marker: { size: 12, color: TEAM_INFO[2].color },
          hovertemplate: '%{text}<extra></extra>',
          text: groups[2].text,
        },
        {
          name: 'Dire',
          x: groups[3].x,
          y: groups[3].y,
          mode: 'markers',
          type: 'scattergl',
          marker: { size: 12, color: TEAM_INFO[3].color },
          hovertemplate: '%{text}<extra></extra>',
          text: groups[3].text,
        },
        {
          name: 'Other',
          x: groups.other.x,
          y: groups.other.y,
          mode: 'markers',
          type: 'scattergl',
          marker: { size: 10, color: TEAM_INFO.default.color },
          hovertemplate: '%{text}<extra></extra>',
          text: groups.other.text,
        },
      ];

      Plotly.react('mapChart', traces, {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        xaxis: { title: 'X', range: state.axis.x, scaleanchor: 'y' },
        yaxis: { title: 'Y', range: state.axis.y },
        legend: { orientation: 'h' },
        margin: { l: 60, r: 20, t: 40, b: 40 },
        title: `Tick ${tick}`,
      }, { responsive: true, displaylogo: false });
    }

    function updateTickLabel(idx) {
      const tick = state.ticks[idx] ?? 0;
      const time = state.tickTimes.get(tick) ?? tick / 30;
      const clock = formatClock(time);
      tickLabel.textContent = `Tick ${tick} (${clock})`;
    }

    const displayInt = (value) => (Number.isFinite(value) && value >= 0 ? numberFmt.format(Math.round(value)) : '—');
    const displayGold = (value) => (Number.isFinite(value) && value >= 0 ? numberFmt.format(Math.round(value)) : '—');
    const displayRate = (value) => (Number.isFinite(value) && value >= 0 ? floatFmt.format(value) : '—');
    const displayHp = (hp, max) => {
      if (!Number.isFinite(hp) || hp < 0 || !Number.isFinite(max) || max <= 0) return '—';
      return `${numberFmt.format(Math.round(hp))}/${numberFmt.format(Math.round(max))}`;
    };
    const displayMana = (mana, max) => {
      if (!Number.isFinite(mana) || mana < 0 || !Number.isFinite(max) || max <= 0) return '—';
      return `${floatFmt.format(mana)}/${floatFmt.format(max)}`;
    };
    const sanitizeValue = (value) => (Number.isFinite(value) && value >= 0 ? value : null);

    function formatClock(seconds) {
      if (!Number.isFinite(seconds)) return '—';
      const total = Math.max(0, seconds);
      const m = Math.floor(total / 60);
      const s = Math.floor(total % 60);
      return `${m}:${s.toString().padStart(2, '0')}`;
    }

    async function loadDefaultCsv() {
      const candidates = [
        'hero_stats.csv',
        './hero_stats.csv',
        '../hero_stats.csv',
        './viz/hero_stats.csv',
        '../../hero_stats.csv',
      ];
      try {
        for (const url of candidates) {
          try {
            const response = await fetch(url, { cache: 'no-store' });
            if (!response.ok) continue;
            const text = await response.text();
            const rows = await parseCsvText(text);
            if (rows.length) {
              await renderRows(rows, url);
              return;
            }
          } catch (err) {
            console.debug(`デフォルトCSV ${url} の読み込みに失敗`, err);
          }
        }
      } catch (err) {
        console.debug('Default CSV 読み込みをスキップしました', err);
      }
    }

    window.addEventListener('DOMContentLoaded', () => {
      loadDefaultCsv();
    });
  </script>
</body>
</html>
